// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package Example

import (
	flatbuffers "github.com/tsingson/goflatbuffers/go"
)

type UCharT struct {
	Inventory []byte
	Inventory1 []int8
	ColorList []Color
}

// UCharT object pack function
func (t *UCharT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	inventoryOffset := flatbuffers.UOffsetT(0)
	if t.Inventory != nil {
		inventoryOffset = builder.CreateByteString(t.Inventory)
	}
	inventory1Offset := flatbuffers.UOffsetT(0)
	if t.Inventory1 != nil {
		inventory1Length := len(t.Inventory1)
		UCharStartInventory1Vector(builder, inventory1Length)
		for j := inventory1Length - 1; j >= 0; j-- {
			builder.PrependInt8(t.Inventory1[j])
		}
		inventory1Offset = UCharEndInventory1Vector(builder, inventory1Length)
	}
	colorListOffset := flatbuffers.UOffsetT(0)
	if t.ColorList != nil {
		colorListLength := len(t.ColorList)
		UCharStartColorListVector(builder, colorListLength)
		for j := colorListLength - 1; j >= 0; j-- {
			builder.PrependInt8(int8(t.ColorList[j]))
		}
		colorListOffset = UCharEndColorListVector(builder, colorListLength)
	}

	// pack process all field

	UCharStart(builder)
	UCharAddInventory(builder, inventoryOffset)
	UCharAddInventory1(builder, inventory1Offset)
	UCharAddColorList(builder, colorListOffset)
	return UCharEnd(builder)
}

// UCharT object unpack function
func (rcv *UChar) UnPackTo(t *UCharT) {
	t.Inventory = rcv.InventoryBytes()
	inventory1Length := rcv.Inventory1Length()
	t.Inventory1 = make([]int8, inventory1Length)
	for j := 0; j < inventory1Length; j++ {
		t.Inventory1[j] = rcv.Inventory1(j)	}
	colorListLength := rcv.ColorListLength()
	t.ColorList = make([]Color, colorListLength)
	for j := 0; j < colorListLength; j++ {
		t.ColorList[j] = rcv.ColorList(j)	}
}

func (rcv *UChar) UnPack() *UCharT {
	if rcv == nil {
		return nil
	}
	t := &UCharT{}
	rcv.UnPackTo(t)
	return t
}

type UChar struct {
	_tab flatbuffers.Table
}

// GetRootAsUChar shortcut to access root table
func GetRootAsUChar(buf []byte, offset flatbuffers.UOffsetT) *UChar {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &UChar{}
	x.Init(buf, n+offset)
	return x
}

// GetTableVectorAsUChar shortcut to access table in vector of  unions
func GetTableVectorAsUChar(table *flatbuffers.Table) *UChar {
	n := flatbuffers.GetUOffsetT(table.Bytes[table.Pos:])
	x := &UChar{}
	x.Init(table.Bytes, n+table.Pos)
	return x
}

// GetTableAsUChar shortcut to access table in single union field
func GetTableAsUChar(table *flatbuffers.Table) *UChar {
	x := &UChar{}
	x.Init(table.Bytes, table.Pos)
	return x
}

func (rcv *UChar) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *UChar) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *UChar) InventoryLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *UChar) InventoryBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *UChar) MutateInventory(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a + flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *UChar) Inventory1Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *UChar) Inventory1(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *UChar) MutateInventory1(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a + flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *UChar) ColorListLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *UChar) ColorList(j int) Color {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return Color(rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1)))
	}
	return 0
}

func (rcv *UChar) MutateColorList(j int, n Color) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a + flatbuffers.UOffsetT(j*1), int8(n))
	}
	return false
}

func UCharStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}

func UCharStartInventoryVector(builder *flatbuffers.Builder, numElems int) {
	builder.StartVector(1, numElems, 1)
}

func UCharEndInventoryVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.EndVector(numElems)
}

func UCharAddInventory(builder *flatbuffers.Builder, inventory flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(inventory), 0)
}

func UCharStartInventory1Vector(builder *flatbuffers.Builder, numElems int) {
	builder.StartVector(1, numElems, 1)
}

func UCharEndInventory1Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.EndVector(numElems)
}

func UCharAddInventory1(builder *flatbuffers.Builder, inventory1 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(inventory1), 0)
}

func UCharStartColorListVector(builder *flatbuffers.Builder, numElems int) {
	builder.StartVector(1, numElems, 1)
}

func UCharEndColorListVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.EndVector(numElems)
}

func UCharAddColorList(builder *flatbuffers.Builder, colorList flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(colorList), 0)
}

func UCharEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
