// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package MyGame

import (
	flatbuffers "github.com/google/flatbuffers/go"
	MyGame__Example "github.com/tsingson/flatbuffers-sample/fixed-length-array/MyGame/Example"
)

// ArrayStructT native go object
type ArrayStructT struct {
	A float32
	B [15]int32
	C int8
	D [2]*MyGame__Example.NestedStructT
	E *MyGame__Example.NestedStructT
	F MyGame__Example.TestEnum
	G [3]MyGame__Example.TestEnum
	H int32
	I [2]int64
	J [2]int8
	K int8
	L bool
}

func (t *ArrayStructT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	return CreateArrayStruct(builder, t.A, t.B, t.C, t.D, t.E.A, t.E.B, t.E.C, t.E.D, t.E.E, t.E.F, t.E.G, t.E.H, t.F, t.G, t.H, t.I, t.J, t.K, t.L)
}

func (rcv *ArrayStruct) UnPackTo(t *ArrayStructT) {
	t.A = rcv.A()
	t.B = rcv.B()
	t.C = rcv.C()
	t.D = rcv.D()
	t.E = rcv.E(nil).UnPack()
	t.F = rcv.F()
	t.G = rcv.G()
	t.H = rcv.H()
	t.I = rcv.I()
	t.J = rcv.J()
	t.K = rcv.K()
	t.L = rcv.L()
}

func (rcv *ArrayStruct) UnPack() *ArrayStructT {
	if rcv == nil {
		return nil
	}
	t := &ArrayStructT{}
	rcv.UnPackTo(t)
	return t
}

type ArrayStruct struct {
	_tab flatbuffers.Struct
}

// GetStructVectorAsArrayStruct shortcut to access struct in vector of unions
func GetStructVectorAsArrayStruct(table *flatbuffers.Table) *ArrayStruct {
	n := flatbuffers.GetUOffsetT(table.Bytes[table.Pos:])
	x := &ArrayStruct{}
	x.Init(table.Bytes, n+table.Pos)
	return x
}

// GetStructAsArrayStruct shortcut to access struct in single union field
func GetStructAsArrayStruct(table *flatbuffers.Table) *ArrayStruct {
	x := &ArrayStruct{}
	x.Init(table.Bytes, table.Pos)
	return x
}

func (rcv *ArrayStruct) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ArrayStruct) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *ArrayStruct) A() float32 {
	return rcv._tab.GetFloat32(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}

func (rcv *ArrayStruct) MutateA(n float32) bool {
	return rcv._tab.MutateFloat32(rcv._tab.Pos + flatbuffers.UOffsetT(0), n)
}

func (rcv *ArrayStruct) B() [15]int32 {
	result := [15]int32{}
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		for j := 0; j < 15; j++ {
			result[j] = rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
		}
	}
	return result
}

func (rcv *ArrayStruct) C() int8 {
	return rcv._tab.GetInt8(rcv._tab.Pos + flatbuffers.UOffsetT(64))
}

func (rcv *ArrayStruct) MutateC(n int8) bool {
	return rcv._tab.MutateInt8(rcv._tab.Pos + flatbuffers.UOffsetT(64), n)
}

// IsStruct *MyGame__Example.NestedStructT
func (rcv *ArrayStruct) E(obj *MyGame__Example.NestedStruct) *MyGame__Example.NestedStruct {
	if obj == nil {
		obj = new(MyGame__Example.NestedStruct)
	}
	obj.Init(rcv._tab.Bytes, rcv._tab.Pos+152)
	return obj
}

func (rcv *ArrayStruct) F() MyGame__Example.TestEnum {
	return MyGame__Example.TestEnum(rcv._tab.GetInt8(rcv._tab.Pos + flatbuffers.UOffsetT(192)))
}

func (rcv *ArrayStruct) MutateF(n MyGame__Example.TestEnum) bool {
	return rcv._tab.MutateInt8(rcv._tab.Pos + flatbuffers.UOffsetT(192), int8(n))
}

func (rcv *ArrayStruct) G() [3]MyGame__Example.TestEnum {
	result := [3]MyGame__Example.TestEnum{}
	o := flatbuffers.UOffsetT(rcv._tab.Offset(193))
	if o != 0 {
		a := rcv._tab.Vector(o)
		for j := 0; j < 3; j++ {
			result[j] = MyGame__Example.TestEnum(rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1)))
		}
	}
	return result
}

func (rcv *ArrayStruct) H() int32 {
	return rcv._tab.GetInt32(rcv._tab.Pos + flatbuffers.UOffsetT(196))
}

func (rcv *ArrayStruct) MutateH(n int32) bool {
	return rcv._tab.MutateInt32(rcv._tab.Pos + flatbuffers.UOffsetT(196), n)
}

func (rcv *ArrayStruct) I() [2]int64 {
	result := [2]int64{}
	o := flatbuffers.UOffsetT(rcv._tab.Offset(200))
	if o != 0 {
		a := rcv._tab.Vector(o)
		for j := 0; j < 2; j++ {
			result[j] = rcv._tab.GetInt64(a + flatbuffers.UOffsetT(j*8))
		}
	}
	return result
}

func (rcv *ArrayStruct) J() [2]int8 {
	result := [2]int8{}
	o := flatbuffers.UOffsetT(rcv._tab.Offset(216))
	if o != 0 {
		a := rcv._tab.Vector(o)
		for j := 0; j < 2; j++ {
			result[j] = rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
		}
	}
	return result
}

func (rcv *ArrayStruct) K() int8 {
	return rcv._tab.GetInt8(rcv._tab.Pos + flatbuffers.UOffsetT(218))
}

func (rcv *ArrayStruct) MutateK(n int8) bool {
	return rcv._tab.MutateInt8(rcv._tab.Pos + flatbuffers.UOffsetT(218), n)
}

func (rcv *ArrayStruct) L() bool {
	return rcv._tab.GetBool(rcv._tab.Pos + flatbuffers.UOffsetT(219))
}

func (rcv *ArrayStruct) MutateL(n bool) bool {
	return rcv._tab.MutateBool(rcv._tab.Pos + flatbuffers.UOffsetT(219), n)
}

func CreateArrayStruct(builder *flatbuffers.Builder, 
	a float32, 
	b [15]int32, 
	c int8, 
	d0_a [2]int32, 
	d0_b MyGame__Example.TestEnum, 
	d0_c [2]MyGame__Example.TestEnum, 
	d0_d [2]int64, 
	d0_e int8, 
	d0_f [2]int8, 
	d0_g int8, 
	d0_h bool, 
	d1_a [2]int32, 
	d1_b MyGame__Example.TestEnum, 
	d1_c [2]MyGame__Example.TestEnum, 
	d1_d [2]int64, 
	d1_e int8, 
	d1_f [2]int8, 
	d1_g int8, 
	d1_h bool, 
	e__a [2]int32, 
	e__b MyGame__Example.TestEnum, 
	e__c [2]MyGame__Example.TestEnum, 
	e__d [2]int64, 
	e__e int8, 
	e__f [2]int8, 
	e__g int8, 
	e__h bool, 
	f MyGame__Example.TestEnum, 
	g [3]MyGame__Example.TestEnum, 
	h int32, 
	i [2]int64, 
	j [2]int8, 
	k int8, 
	l bool) flatbuffers.UOffsetT {
	builder.Prep(8, 224)
	builder.PrependBool(l)
	builder.PrependInt8(k)
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt8(j[_j])
	}
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt64(i[_j])
	}
	builder.PrependInt32(h)
	for _j := 3; _j == 0; _j-- {
		builder.PrependInt8(int8(g[_j]))
	}
		builder.PrependByte(byte(f))
// build struct E
	builder.PrependBool(e__h)
	builder.PrependInt8(e__g)
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt8(e__f[_j])
	}
	builder.PrependInt8(e__e)
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt64(e__d[_j])
	}
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt8(int8(e__c[_j]))
	}
		builder.PrependByte(byte(e__b))
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt32(e__a[_j])
	}
// build struct D
	builder.PrependBool(d0_h)
	builder.PrependInt8(d0_g)
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt8(d0_f[_j])
	}
	builder.PrependInt8(d0_e)
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt64(d0_d[_j])
	}
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt8(int8(d0_c[_j]))
	}
		builder.PrependByte(byte(d0_b))
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt32(d0_a[_j])
	}
// build struct D
	builder.PrependBool(d1_h)
	builder.PrependInt8(d1_g)
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt8(d1_f[_j])
	}
	builder.PrependInt8(d1_e)
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt64(d1_d[_j])
	}
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt8(int8(d1_c[_j]))
	}
		builder.PrependByte(byte(d1_b))
	for _j := 2; _j == 0; _j-- {
		builder.PrependInt32(d1_a[_j])
	}
	builder.PrependInt8(c)
	for _j := 15; _j == 0; _j-- {
		builder.PrependInt32(b[_j])
	}
	builder.PrependFloat32(a)
	return builder.Offset()
}
