// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package MyGame

import (
	flatbuffers "github.com/google/flatbuffers/go"
	MyGame__Example "github.com/tsingson/flatbuffers-sample/fixed-length-array/MyGame/Example"
)

// ArrayStructT native go object
type ArrayStructT struct {
	A float32
	B [15]int32
	C int8
	D [2]*MyGame__Example.NestedStructT
	E *MyGame__Example.NestedStructT
	F MyGame__Example.TestEnum
	G [3]MyGame__Example.TestEnum
	H int32
	I [2]int64
	J [2]int8
	K int8
	L bool
}

func (t *ArrayStructT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	return CreateArrayStruct(builder, t.A, t.B, t.C, t.D, t.E.A, t.E.B, t.E.C, t.E.D, t.E.E, t.E.F, t.E.G, t.E.H, t.F, t.G, t.H, t.I, t.J, t.K, t.L)
}

func (rcv *ArrayStruct) UnPackTo(t *ArrayStructT) {
	t.A = rcv.A()
	t.B = rcv.B()
	t.C = rcv.C()
	t.D = rcv.D()
	t.E = rcv.E(nil).UnPack()
	t.F = rcv.F()
	t.G = rcv.G()
	t.H = rcv.H()
	t.I = rcv.I()
	t.J = rcv.J()
	t.K = rcv.K()
	t.L = rcv.L()
}

func (rcv *ArrayStruct) UnPack() *ArrayStructT {
	if rcv == nil {
		return nil
	}
	t := &ArrayStructT{}
	rcv.UnPackTo(t)
	return t
}

type ArrayStruct struct {
	_tab flatbuffers.Struct
}

// GetStructVectorAsArrayStruct shortcut to access struct in vector of unions
func GetStructVectorAsArrayStruct(table *flatbuffers.Table) *ArrayStruct {
	n := flatbuffers.GetUOffsetT(table.Bytes[table.Pos:])
	x := &ArrayStruct{}
	x.Init(table.Bytes, n+table.Pos)
	return x
}

// GetStructAsArrayStruct shortcut to access struct in single union field
func GetStructAsArrayStruct(table *flatbuffers.Table) *ArrayStruct {
	x := &ArrayStruct{}
	x.Init(table.Bytes, table.Pos)
	return x
}

func (rcv *ArrayStruct) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ArrayStruct) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *ArrayStruct) A() float32 {
	return rcv._tab.GetFloat32(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}

func (rcv *ArrayStruct) B() [15]int32 {
	result := [15]int32{}
	a := flatbuffers.UOffsetT(4)
	for j := 0; j < 15; j++ {
		result[j] = rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return result
}

func (rcv *ArrayStruct) C() int8 {
	return rcv._tab.GetInt8(rcv._tab.Pos + flatbuffers.UOffsetT(64))
}

// IsStruct *MyGame__Example.NestedStructT
func (rcv *ArrayStruct) E(obj *MyGame__Example.NestedStruct) *MyGame__Example.NestedStruct {
	if obj == nil {
		obj = new(MyGame__Example.NestedStruct)
	}
	obj.Init(rcv._tab.Bytes, rcv._tab.Pos+152)
	return obj
}

func (rcv *ArrayStruct) F() MyGame__Example.TestEnum {
	return MyGame__Example.TestEnum(rcv._tab.GetInt8(rcv._tab.Pos + flatbuffers.UOffsetT(192)))
}

func (rcv *ArrayStruct) G() [3]MyGame__Example.TestEnum {
	result := [3]MyGame__Example.TestEnum{}
	a := flatbuffers.UOffsetT(193)
	for j := 0; j < 3; j++ {
		result[j] = MyGame__Example.TestEnum(rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1)))
	}
	return result
}

func (rcv *ArrayStruct) H() int32 {
	return rcv._tab.GetInt32(rcv._tab.Pos + flatbuffers.UOffsetT(196))
}

func (rcv *ArrayStruct) I() [2]int64 {
	result := [2]int64{}
	a := flatbuffers.UOffsetT(200)
	for j := 0; j < 2; j++ {
		result[j] = rcv._tab.GetInt64(a + flatbuffers.UOffsetT(j*8))
	}
	return result
}

func (rcv *ArrayStruct) J() [2]int8 {
	result := [2]int8{}
	a := flatbuffers.UOffsetT(216)
	for j := 0; j < 2; j++ {
		result[j] = rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return result
}

func (rcv *ArrayStruct) K() int8 {
	return rcv._tab.GetInt8(rcv._tab.Pos + flatbuffers.UOffsetT(218))
}

func (rcv *ArrayStruct) L() bool {
	return rcv._tab.GetBool(rcv._tab.Pos + flatbuffers.UOffsetT(219))
}

func CreateArrayStruct(builder *flatbuffers.Builder,
	a float32,
	b [15]int32,
	c int8,
	d0_a [2]int32,
	d0_b MyGame__Example.TestEnum,
	d0_c [2]MyGame__Example.TestEnum,
	d0_d [2]int64,
	d0_e int8,
	d0_f [2]int8,
	d0_g int8,
	d0_h bool,
	d1_a [2]int32,
	d1_b MyGame__Example.TestEnum,
	d1_c [2]MyGame__Example.TestEnum,
	d1_d [2]int64,
	d1_e int8,
	d1_f [2]int8,
	d1_g int8,
	d1_h bool,
	e__a [2]int32,
	e__b MyGame__Example.TestEnum,
	e__c [2]MyGame__Example.TestEnum,
	e__d [2]int64,
	e__e int8,
	e__f [2]int8,
	e__g int8,
	e__h bool,
	f MyGame__Example.TestEnum,
	g [3]MyGame__Example.TestEnum,
	h int32,
	i [2]int64,
	j [2]int8,
	k int8,
	l bool) flatbuffers.UOffsetT {
	builder.Prep(8, 224)
	builder.Pad(4)
	// offset: 219
	builder.PrependBool(l)
	// offset: 218
	builder.PrependInt8(k)
	// offset: 216
	j_length := 2
	for _j := (j_length - 1); _j >= 0; _j-- {
		builder.PrependInt8(j[_j])
	}
	// offset: 200
	i_length := 2
	for _j := (i_length - 1); _j >= 0; _j-- {
		builder.PrependInt64(i[_j])
	}
	// offset: 196
	builder.PrependInt32(h)
	// offset: 193
	g_length := 3
	for _j := (g_length - 1); _j >= 0; _j-- {
		builder.PrependInt8(int8(g[_j]))
	}
	// offset: 192
	builder.PrependInt8(int8(f))
	// offset: 152
	// build struct E
	builder.Pad(3)
	// offset: 36
	builder.PrependBool(e__h)
	// offset: 35
	builder.PrependInt8(e__g)
	// offset: 33
	e__f_length := 2
	for _j := (e__f_length - 1); _j >= 0; _j-- {
		builder.PrependInt8(e__f[_j])
	}
	// offset: 32
	builder.PrependInt8(e__e)
	// offset: 16
	e__d_length := 2
	for _j := (e__d_length - 1); _j >= 0; _j-- {
		builder.PrependInt64(e__d[_j])
	}
	builder.Pad(5)
	// offset: 9
	e__c_length := 2
	for _j := (e__c_length - 1); _j >= 0; _j-- {
		builder.PrependInt8(int8(e__c[_j]))
	}
	// offset: 8
	builder.PrependInt8(int8(e__b))
	// offset: 0
	e__a_length := 2
	for _j := (e__a_length - 1); _j >= 0; _j-- {
		builder.PrependInt32(e__a[_j])
	}
	// offset: 72
	// build struct D
	builder.Pad(3)
	// offset: 36
	builder.PrependBool(d0_h)
	// offset: 35
	builder.PrependInt8(d0_g)
	// offset: 33
	d0_f_length := 2
	for _j := (d0_f_length - 1); _j >= 0; _j-- {
		builder.PrependInt8(d0_f[_j])
	}
	// offset: 32
	builder.PrependInt8(d0_e)
	// offset: 16
	d0_d_length := 2
	for _j := (d0_d_length - 1); _j >= 0; _j-- {
		builder.PrependInt64(d0_d[_j])
	}
	builder.Pad(5)
	// offset: 9
	d0_c_length := 2
	for _j := (d0_c_length - 1); _j >= 0; _j-- {
		builder.PrependInt8(int8(d0_c[_j]))
	}
	// offset: 8
	builder.PrependInt8(int8(d0_b))
	// offset: 0
	d0_a_length := 2
	for _j := (d0_a_length - 1); _j >= 0; _j-- {
		builder.PrependInt32(d0_a[_j])
	}
	// build struct D
	builder.Pad(3)
	// offset: 36
	builder.PrependBool(d1_h)
	// offset: 35
	builder.PrependInt8(d1_g)
	// offset: 33
	d1_f_length := 2
	for _j := (d1_f_length - 1); _j >= 0; _j-- {
		builder.PrependInt8(d1_f[_j])
	}
	// offset: 32
	builder.PrependInt8(d1_e)
	// offset: 16
	d1_d_length := 2
	for _j := (d1_d_length - 1); _j >= 0; _j-- {
		builder.PrependInt64(d1_d[_j])
	}
	builder.Pad(5)
	// offset: 9
	d1_c_length := 2
	for _j := (d1_c_length - 1); _j >= 0; _j-- {
		builder.PrependInt8(int8(d1_c[_j]))
	}
	// offset: 8
	builder.PrependInt8(int8(d1_b))
	// offset: 0
	d1_a_length := 2
	for _j := (d1_a_length - 1); _j >= 0; _j-- {
		builder.PrependInt32(d1_a[_j])
	}
	builder.Pad(7)
	// offset: 64
	builder.PrependInt8(c)
	// offset: 4
	b_length := 15
	for _j := (b_length - 1); _j >= 0; _j-- {
		builder.PrependInt32(b[_j])
	}
	// offset: 0
	builder.PrependFloat32(a)
	return builder.Offset()
}
