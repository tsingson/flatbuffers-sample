// automatically generated by the FlatBuffers compiler, do not modify

import {flatbuffers} from "./flatbuffers"

/**
 * @enum {number}
 */
export namespace MyGame.Sample {
    export enum Color {
        Red = 0,
        Green = 1,
        Blue = 2
    };
}

/**
 * @enum {number}
 */
export namespace MyGame.Sample {
    export enum Equipment {
        NONE = 0,
        MuLan = 1,
        Weapon = 2,
        Gun = 3
    };

    export function unionToEquipment(
        type: Equipment,
        accessor: (obj: MyGame.Sample.Weapon | weapons.Gun) => MyGame.Sample.Weapon | weapons.Gun | null
    ): MyGame.Sample.Weapon | weapons.Gun | null {
        switch (MyGame.Sample.Equipment[type]) {
            case 'NONE':
                return null;
            case 'MuLan':
                return accessor(new MyGame.Sample.Weapon())! as MyGame.Sample.Weapon;
            case 'Weapon':
                return accessor(new MyGame.Sample.Weapon())! as MyGame.Sample.Weapon;
            case 'Gun':
                return accessor(new weapons.Gun())! as weapons.Gun;
            default:
                return null;
        }
    }

    export function unionListToEquipment(
        type: Equipment,
        accessor: (index: number, obj: MyGame.Sample.Weapon | weapons.Gun) => MyGame.Sample.Weapon | weapons.Gun | null,
        index: number
    ): MyGame.Sample.Weapon | weapons.Gun | null {
        switch (MyGame.Sample.Equipment[type]) {
            case 'NONE':
                return null;
            case 'MuLan':
                return accessor(index, new MyGame.Sample.Weapon())! as MyGame.Sample.Weapon;
            case 'Weapon':
                return accessor(index, new MyGame.Sample.Weapon())! as MyGame.Sample.Weapon;
            case 'Gun':
                return accessor(index, new weapons.Gun())! as weapons.Gun;
            default:
                return null;
        }
    }
}

/**
 * @enum {number}
 */
export namespace MyGame {
    export enum Character {
        NONE = 0,
        weapon = 1,
        Monster = 2
    };

    export function unionToCharacter(
        type: Character,
        accessor: (obj: MyGame.Sample.Monster | weapons.Gun) => MyGame.Sample.Monster | weapons.Gun | null
    ): MyGame.Sample.Monster | weapons.Gun | null {
        switch (MyGame.Character[type]) {
            case 'NONE':
                return null;
            case 'weapon':
                return accessor(new weapons.Gun())! as weapons.Gun;
            case 'Monster':
                return accessor(new MyGame.Sample.Monster())! as MyGame.Sample.Monster;
            default:
                return null;
        }
    }

    export function unionListToCharacter(
        type: Character,
        accessor: (index: number, obj: MyGame.Sample.Monster | weapons.Gun) => MyGame.Sample.Monster | weapons.Gun | null,
        index: number
    ): MyGame.Sample.Monster | weapons.Gun | null {
        switch (MyGame.Character[type]) {
            case 'NONE':
                return null;
            case 'weapon':
                return accessor(index, new weapons.Gun())! as weapons.Gun;
            case 'Monster':
                return accessor(index, new MyGame.Sample.Monster())! as MyGame.Sample.Monster;
            default:
                return null;
        }
    }
}

/**
 * @constructor
 */
export namespace weapons {
    export class Gun {
        bb: flatbuffers.ByteBuffer | null = null;

        bb_pos: number = 0;

        /**
         * @param number i
         * @param flatbuffers.ByteBuffer bb
         * @returns Gun
         */
        __init(i: number, bb: flatbuffers.ByteBuffer): Gun {
            this.bb_pos = i;
            this.bb = bb;
            return this;
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param Gun= obj
         * @returns Gun
         */
        static getRootAsGun(bb: flatbuffers.ByteBuffer, obj?: Gun): Gun {
            return (obj || new Gun()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param Gun= obj
         * @returns Gun
         */
        static getSizePrefixedRootAsGun(bb: flatbuffers.ByteBuffer, obj?: Gun): Gun {
            bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
            return (obj || new Gun()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @returns number
         */
        damage(): number {
            var offset = this.bb!.__offset(this.bb_pos, 4);
            return offset ? this.bb!.readInt16(this.bb_pos + offset) : 0;
        };

        /**
         * @returns boolean
         */
        bool(): boolean {
            var offset = this.bb!.__offset(this.bb_pos, 6);
            return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
        };

        /**
         * @param flatbuffers.Encoding= optionalEncoding
         * @returns string|Uint8Array|null
         */
        name(): string | null
        name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
        name(optionalEncoding?: any): string | Uint8Array | null {
            var offset = this.bb!.__offset(this.bb_pos, 8);
            return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
        };

        /**
         * @param number index
         * @param flatbuffers.Encoding= optionalEncoding
         * @returns string|Uint8Array
         */
        names(index: number): string
        names(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array
        names(index: number, optionalEncoding?: any): string | Uint8Array | null {
            var offset = this.bb!.__offset(this.bb_pos, 10);
            return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
        };

        /**
         * @returns number
         */
        namesLength(): number {
            var offset = this.bb!.__offset(this.bb_pos, 10);
            return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
        };

        /**
         * @param flatbuffers.Builder builder
         */
        static startGun(builder: flatbuffers.Builder) {
            builder.startObject(4);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number damage
         */
        static addDamage(builder: flatbuffers.Builder, damage: number) {
            builder.addFieldInt16(0, damage, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param boolean bool
         */
        static addBool(builder: flatbuffers.Builder, bool: boolean) {
            builder.addFieldInt8(1, +bool, +false);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset nameOffset
         */
        static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
            builder.addFieldOffset(2, nameOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset namesOffset
         */
        static addNames(builder: flatbuffers.Builder, namesOffset: flatbuffers.Offset) {
            builder.addFieldOffset(3, namesOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param Array.<flatbuffers.Offset> data
         * @returns flatbuffers.Offset
         */
        static createNamesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {
            builder.startVector(4, data.length, 4);
            for (var i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
            }
            return builder.endVector();
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number numElems
         */
        static startNamesVector(builder: flatbuffers.Builder, numElems: number) {
            builder.startVector(4, numElems, 4);
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        static endGun(builder: flatbuffers.Builder): flatbuffers.Offset {
            var offset = builder.endObject();
            return offset;
        };

        static createGun(builder: flatbuffers.Builder, damage: number, bool: boolean, nameOffset: flatbuffers.Offset, namesOffset: flatbuffers.Offset): flatbuffers.Offset {
            Gun.startGun(builder);
            Gun.addDamage(builder, damage);
            Gun.addBool(builder, bool);
            Gun.addName(builder, nameOffset);
            Gun.addNames(builder, namesOffset);
            return Gun.endGun(builder);
        }

        /**
         * @returns GunT
         */
        unpack(): GunT {
            return new GunT(
                this.damage(),
                this.bool(),
                this.name(),
                this.bb!.createStringList(this.names.bind(this), this.namesLength())
            );
        };

        /**
         * @param GunT _o
         */
        unpackTo(_o: GunT): void {
            _o.damage = this.damage();
            _o.bool = this.bool();
            _o.name = this.name();
            _o.names = this.bb!.createStringList(this.names.bind(this), this.namesLength());
        };
    }

    export class GunT {
        /**
         * @constructor
         * @param number damage
         * @param boolean bool
         * @param string|Uint8Array|null name
         * @param (string)[] names
         */
        constructor(
            public damage: number = 0,
            public bool: boolean = false,
            public name: string | Uint8Array | null = null,
            public names: (string)[] = []
        ) {
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        pack(builder: flatbuffers.Builder): flatbuffers.Offset {
            const name = (this.name !== null ? builder.createString(this.name!) : 0);
            const names = Gun.createNamesVector(builder, builder.createObjectOffsetList(this.names));

            return Gun.createGun(builder,
                this.damage,
                this.bool,
                name,
                names
            );
        };
    }
}
/**
 * @constructor
 */
export namespace weapons {
    export class Master {
        bb: flatbuffers.ByteBuffer | null = null;

        bb_pos: number = 0;

        /**
         * @param number i
         * @param flatbuffers.ByteBuffer bb
         * @returns Master
         */
        __init(i: number, bb: flatbuffers.ByteBuffer): Master {
            this.bb_pos = i;
            this.bb = bb;
            return this;
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param Master= obj
         * @returns Master
         */
        static getRootAsMaster(bb: flatbuffers.ByteBuffer, obj?: Master): Master {
            return (obj || new Master()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param Master= obj
         * @returns Master
         */
        static getSizePrefixedRootAsMaster(bb: flatbuffers.ByteBuffer, obj?: Master): Master {
            bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
            return (obj || new Master()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param flatbuffers.Builder builder
         */
        static startMaster(builder: flatbuffers.Builder) {
            builder.startObject(0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        static endMaster(builder: flatbuffers.Builder): flatbuffers.Offset {
            var offset = builder.endObject();
            return offset;
        };

        static createMaster(builder: flatbuffers.Builder): flatbuffers.Offset {
            Master.startMaster(builder);
            return Master.endMaster(builder);
        }

        /**
         * @returns MasterT
         */
        unpack(): MasterT {
            return new MasterT();
        };

        /**
         * @param MasterT _o
         */
        unpackTo(_o: MasterT): void {
        };
    }

    export class MasterT {
        /**
         * @constructor
         */
        constructor() {
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        pack(builder: flatbuffers.Builder): flatbuffers.Offset {
            return Master.createMaster(builder);
        };
    }
}
/**
 * @constructor
 */
export namespace MyGame.Sample {
    export class Vec3 {
        bb: flatbuffers.ByteBuffer | null = null;

        bb_pos: number = 0;

        /**
         * @param number i
         * @param flatbuffers.ByteBuffer bb
         * @returns Vec3
         */
        __init(i: number, bb: flatbuffers.ByteBuffer): Vec3 {
            this.bb_pos = i;
            this.bb = bb;
            return this;
        };

        /**
         * @returns number
         */
        x(): number {
            return this.bb!.readFloat32(this.bb_pos);
        };

        /**
         * @returns number
         */
        y(): number {
            return this.bb!.readFloat32(this.bb_pos + 4);
        };

        /**
         * @returns number
         */
        z(): number {
            return this.bb!.readFloat32(this.bb_pos + 8);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number x
         * @param number y
         * @param number z
         * @returns flatbuffers.Offset
         */
        static createVec3(builder: flatbuffers.Builder, x: number, y: number, z: number): flatbuffers.Offset {
            builder.prep(4, 12);
            builder.writeFloat32(z);
            builder.writeFloat32(y);
            builder.writeFloat32(x);
            return builder.offset();
        };


        /**
         * @returns Vec3T
         */
        unpack(): Vec3T {
            return new Vec3T(
                this.x(),
                this.y(),
                this.z()
            );
        };

        /**
         * @param Vec3T _o
         */
        unpackTo(_o: Vec3T): void {
            _o.x = this.x();
            _o.y = this.y();
            _o.z = this.z();
        };
    }

    export class Vec3T {
        /**
         * @constructor
         * @param number x
         * @param number y
         * @param number z
         */
        constructor(
            public x: number = 0.0,
            public y: number = 0.0,
            public z: number = 0.0
        ) {
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        pack(builder: flatbuffers.Builder): flatbuffers.Offset {
            return Vec3.createVec3(builder,
                this.x,
                this.y,
                this.z
            );
        };
    }
}
/**
 * @constructor
 */
export namespace MyGame.Sample {
    export class Monster {
        bb: flatbuffers.ByteBuffer | null = null;

        bb_pos: number = 0;

        /**
         * @param number i
         * @param flatbuffers.ByteBuffer bb
         * @returns Monster
         */
        __init(i: number, bb: flatbuffers.ByteBuffer): Monster {
            this.bb_pos = i;
            this.bb = bb;
            return this;
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param Monster= obj
         * @returns Monster
         */
        static getRootAsMonster(bb: flatbuffers.ByteBuffer, obj?: Monster): Monster {
            return (obj || new Monster()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param Monster= obj
         * @returns Monster
         */
        static getSizePrefixedRootAsMonster(bb: flatbuffers.ByteBuffer, obj?: Monster): Monster {
            bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
            return (obj || new Monster()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param MyGame.Sample.Vec3= obj
         * @returns MyGame.Sample.Vec3|null
         */
        pos(obj?: MyGame.Sample.Vec3): MyGame.Sample.Vec3 | null {
            var offset = this.bb!.__offset(this.bb_pos, 4);
            return offset ? (obj || new MyGame.Sample.Vec3()).__init(this.bb_pos + offset, this.bb!) : null;
        };

        /**
         * @returns number
         */
        mana(): number {
            var offset = this.bb!.__offset(this.bb_pos, 6);
            return offset ? this.bb!.readInt16(this.bb_pos + offset) : 150;
        };

        /**
         * @returns number
         */
        hp(): number {
            var offset = this.bb!.__offset(this.bb_pos, 8);
            return offset ? this.bb!.readInt16(this.bb_pos + offset) : 100;
        };

        /**
         * @param flatbuffers.Encoding= optionalEncoding
         * @returns string|Uint8Array|null
         */
        name(): string | null
        name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
        name(optionalEncoding?: any): string | Uint8Array | null {
            var offset = this.bb!.__offset(this.bb_pos, 10);
            return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
        };

        /**
         * @param number index
         * @param flatbuffers.Encoding= optionalEncoding
         * @returns string|Uint8Array
         */
        names(index: number): string
        names(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array
        names(index: number, optionalEncoding?: any): string | Uint8Array | null {
            var offset = this.bb!.__offset(this.bb_pos, 12);
            return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
        };

        /**
         * @returns number
         */
        namesLength(): number {
            var offset = this.bb!.__offset(this.bb_pos, 12);
            return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
        };

        /**
         * @param number index
         * @returns number
         */
        inventory(index: number): number | null {
            var offset = this.bb!.__offset(this.bb_pos, 16);
            return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
        };

        /**
         * @returns number
         */
        inventoryLength(): number {
            var offset = this.bb!.__offset(this.bb_pos, 16);
            return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
        };

        /**
         * @returns Uint8Array
         */
        inventoryArray(): Uint8Array | null {
            var offset = this.bb!.__offset(this.bb_pos, 16);
            return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
        };

        /**
         * @returns MyGame.Sample.Color
         */
        color(): MyGame.Sample.Color {
            var offset = this.bb!.__offset(this.bb_pos, 18);
            return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) : MyGame.Sample.Color.Blue;
        };

        /**
         * @param number index
         * @param MyGame.Sample.Weapon= obj
         * @returns MyGame.Sample.Weapon
         */
        weapons(index: number, obj?: MyGame.Sample.Weapon): MyGame.Sample.Weapon | null {
            var offset = this.bb!.__offset(this.bb_pos, 20);
            return offset ? (obj || new MyGame.Sample.Weapon()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
        };

        /**
         * @returns number
         */
        weaponsLength(): number {
            var offset = this.bb!.__offset(this.bb_pos, 20);
            return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
        };

        /**
         * @returns MyGame.Sample.Equipment
         */
        equippedType(): MyGame.Sample.Equipment {
            var offset = this.bb!.__offset(this.bb_pos, 22);
            return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : MyGame.Sample.Equipment.NONE;
        };

        /**
         * @param flatbuffers.Table obj
         * @returns ?flatbuffers.Table
         */
        equipped<T extends flatbuffers.Table>(obj: T): T | null {
            var offset = this.bb!.__offset(this.bb_pos, 24);
            return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
        };

        /**
         * @param number index
         * @param MyGame.Sample.Vec3= obj
         * @returns MyGame.Sample.Vec3
         */
        path(index: number, obj?: MyGame.Sample.Vec3): MyGame.Sample.Vec3 | null {
            var offset = this.bb!.__offset(this.bb_pos, 26);
            return offset ? (obj || new MyGame.Sample.Vec3()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 12, this.bb!) : null;
        };

        /**
         * @returns number
         */
        pathLength(): number {
            var offset = this.bb!.__offset(this.bb_pos, 26);
            return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
        };

        /**
         * @param flatbuffers.Builder builder
         */
        static startMonster(builder: flatbuffers.Builder) {
            builder.startObject(12);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset posOffset
         */
        static addPos(builder: flatbuffers.Builder, posOffset: flatbuffers.Offset) {
            builder.addFieldStruct(0, posOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number mana
         */
        static addMana(builder: flatbuffers.Builder, mana: number) {
            builder.addFieldInt16(1, mana, 150);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number hp
         */
        static addHp(builder: flatbuffers.Builder, hp: number) {
            builder.addFieldInt16(2, hp, 100);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset nameOffset
         */
        static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
            builder.addFieldOffset(3, nameOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset namesOffset
         */
        static addNames(builder: flatbuffers.Builder, namesOffset: flatbuffers.Offset) {
            builder.addFieldOffset(4, namesOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param Array.<flatbuffers.Offset> data
         * @returns flatbuffers.Offset
         */
        static createNamesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {
            builder.startVector(4, data.length, 4);
            for (var i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
            }
            return builder.endVector();
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number numElems
         */
        static startNamesVector(builder: flatbuffers.Builder, numElems: number) {
            builder.startVector(4, numElems, 4);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset inventoryOffset
         */
        static addInventory(builder: flatbuffers.Builder, inventoryOffset: flatbuffers.Offset) {
            builder.addFieldOffset(6, inventoryOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param Array.<number> data
         * @returns flatbuffers.Offset
         */
        static createInventoryVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset {
            builder.startVector(1, data.length, 1);
            for (var i = data.length - 1; i >= 0; i--) {
                builder.addInt8(data[i]);
            }
            return builder.endVector();
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number numElems
         */
        static startInventoryVector(builder: flatbuffers.Builder, numElems: number) {
            builder.startVector(1, numElems, 1);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param MyGame.Sample.Color color
         */
        static addColor(builder: flatbuffers.Builder, color: MyGame.Sample.Color) {
            builder.addFieldInt8(7, color, MyGame.Sample.Color.Blue);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset weaponsOffset
         */
        static addWeapons(builder: flatbuffers.Builder, weaponsOffset: flatbuffers.Offset) {
            builder.addFieldOffset(8, weaponsOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param Array.<flatbuffers.Offset> data
         * @returns flatbuffers.Offset
         */
        static createWeaponsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {
            builder.startVector(4, data.length, 4);
            for (var i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
            }
            return builder.endVector();
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number numElems
         */
        static startWeaponsVector(builder: flatbuffers.Builder, numElems: number) {
            builder.startVector(4, numElems, 4);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param MyGame.Sample.Equipment equippedType
         */
        static addEquippedType(builder: flatbuffers.Builder, equippedType: MyGame.Sample.Equipment) {
            builder.addFieldInt8(9, equippedType, MyGame.Sample.Equipment.NONE);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset equippedOffset
         */
        static addEquipped(builder: flatbuffers.Builder, equippedOffset: flatbuffers.Offset) {
            builder.addFieldOffset(10, equippedOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset pathOffset
         */
        static addPath(builder: flatbuffers.Builder, pathOffset: flatbuffers.Offset) {
            builder.addFieldOffset(11, pathOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number numElems
         */
        static startPathVector(builder: flatbuffers.Builder, numElems: number) {
            builder.startVector(12, numElems, 4);
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        static endMonster(builder: flatbuffers.Builder): flatbuffers.Offset {
            var offset = builder.endObject();
            return offset;
        };

        static createMonster(builder: flatbuffers.Builder, posOffset: flatbuffers.Offset, mana: number, hp: number, nameOffset: flatbuffers.Offset, namesOffset: flatbuffers.Offset, inventoryOffset: flatbuffers.Offset, color: MyGame.Sample.Color, weaponsOffset: flatbuffers.Offset, equippedType: MyGame.Sample.Equipment, equippedOffset: flatbuffers.Offset, pathOffset: flatbuffers.Offset): flatbuffers.Offset {
            Monster.startMonster(builder);
            Monster.addPos(builder, posOffset);
            Monster.addMana(builder, mana);
            Monster.addHp(builder, hp);
            Monster.addName(builder, nameOffset);
            Monster.addNames(builder, namesOffset);
            Monster.addInventory(builder, inventoryOffset);
            Monster.addColor(builder, color);
            Monster.addWeapons(builder, weaponsOffset);
            Monster.addEquippedType(builder, equippedType);
            Monster.addEquipped(builder, equippedOffset);
            Monster.addPath(builder, pathOffset);
            return Monster.endMonster(builder);
        }

        /**
         * @returns MonsterT
         */
        unpack(): MonsterT {
            return new MonsterT(
                (this.pos() !== null ? this.pos()!.unpack() : null),
                this.mana(),
                this.hp(),
                this.name(),
                this.bb!.createStringList(this.names.bind(this), this.namesLength()),
                this.bb!.createScalarList(this.inventory.bind(this), this.inventoryLength()),
                this.color(),
                this.bb!.createObjList(this.weapons.bind(this), this.weaponsLength()),
                this.equippedType(),
                (() => {
                    let temp = MyGame.Sample.unionToEquipment(this.equippedType(), this.equipped.bind(this));
                    if (temp === null) {
                        return null;
                    }
                    return temp.unpack()
                })(),
                this.bb!.createObjList(this.path.bind(this), this.pathLength())
            );
        };

        /**
         * @param MonsterT _o
         */
        unpackTo(_o: MonsterT): void {
            _o.pos = (this.pos() !== null ? this.pos()!.unpack() : null);
            _o.mana = this.mana();
            _o.hp = this.hp();
            _o.name = this.name();
            _o.names = this.bb!.createStringList(this.names.bind(this), this.namesLength());
            _o.inventory = this.bb!.createScalarList(this.inventory.bind(this), this.inventoryLength());
            _o.color = this.color();
            _o.weapons = this.bb!.createObjList(this.weapons.bind(this), this.weaponsLength());
            _o.equippedType = this.equippedType();
            _o.equipped = (() => {
                let temp = MyGame.Sample.unionToEquipment(this.equippedType(), this.equipped.bind(this));
                if (temp === null) {
                    return null;
                }
                return temp.unpack()
            })();
            _o.path = this.bb!.createObjList(this.path.bind(this), this.pathLength());
        };
    }

    export class MonsterT {
        /**
         * @constructor
         * @param MyGame.Sample.Vec3T|null pos
         * @param number mana
         * @param number hp
         * @param string|Uint8Array|null name
         * @param (string)[] names
         * @param (number)[] inventory
         * @param MyGame.Sample.Color color
         * @param (MyGame.Sample.WeaponT)[] weapons
         * @param MyGame.Sample.Equipment equippedType
         * @param MyGame.Sample.WeaponT|weapons.GunT|null equipped
         * @param (MyGame.Sample.Vec3T)[] path
         */
        constructor(
            public pos: MyGame.Sample.Vec3T | null = null,
            public mana: number = 150,
            public hp: number = 100,
            public name: string | Uint8Array | null = null,
            public names: (string)[] = [],
            public inventory: (number)[] = [],
            public color: MyGame.Sample.Color = MyGame.Sample.Color.Blue,
            public weapons: (MyGame.Sample.WeaponT)[] = [],
            public equippedType: MyGame.Sample.Equipment = MyGame.Sample.Equipment.NONE,
            public equipped: MyGame.Sample.WeaponT | weapons.GunT | null = null,
            public path: (MyGame.Sample.Vec3T)[] = []
        ) {
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        pack(builder: flatbuffers.Builder): flatbuffers.Offset {
            const name = (this.name !== null ? builder.createString(this.name!) : 0);
            const names = Monster.createNamesVector(builder, builder.createObjectOffsetList(this.names));
            const inventory = Monster.createInventoryVector(builder, this.inventory);
            const weapons = Monster.createWeaponsVector(builder, builder.createObjectOffsetList(this.weapons));
            const equipped = builder.createObjectOffset(this.equipped);
            const path = builder.createStructOffsetList(this.path, Monster.startPathVector);

            return Monster.createMonster(builder,
                (this.pos !== null ? this.pos!.pack(builder) : 0),
                this.mana,
                this.hp,
                name,
                names,
                inventory,
                this.color,
                weapons,
                this.equippedType,
                equipped,
                path
            );
        };
    }
}
/**
 * @constructor
 */
export namespace MyGame.Sample {
    export class Weapon {
        bb: flatbuffers.ByteBuffer | null = null;

        bb_pos: number = 0;

        /**
         * @param number i
         * @param flatbuffers.ByteBuffer bb
         * @returns Weapon
         */
        __init(i: number, bb: flatbuffers.ByteBuffer): Weapon {
            this.bb_pos = i;
            this.bb = bb;
            return this;
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param Weapon= obj
         * @returns Weapon
         */
        static getRootAsWeapon(bb: flatbuffers.ByteBuffer, obj?: Weapon): Weapon {
            return (obj || new Weapon()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param Weapon= obj
         * @returns Weapon
         */
        static getSizePrefixedRootAsWeapon(bb: flatbuffers.ByteBuffer, obj?: Weapon): Weapon {
            bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
            return (obj || new Weapon()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param flatbuffers.Encoding= optionalEncoding
         * @returns string|Uint8Array|null
         */
        name(): string | null
        name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null
        name(optionalEncoding?: any): string | Uint8Array | null {
            var offset = this.bb!.__offset(this.bb_pos, 4);
            return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
        };

        /**
         * @returns number
         */
        damage(): number {
            var offset = this.bb!.__offset(this.bb_pos, 6);
            return offset ? this.bb!.readInt16(this.bb_pos + offset) : 0;
        };

        /**
         * @param flatbuffers.Builder builder
         */
        static startWeapon(builder: flatbuffers.Builder) {
            builder.startObject(2);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset nameOffset
         */
        static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
            builder.addFieldOffset(0, nameOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param number damage
         */
        static addDamage(builder: flatbuffers.Builder, damage: number) {
            builder.addFieldInt16(1, damage, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        static endWeapon(builder: flatbuffers.Builder): flatbuffers.Offset {
            var offset = builder.endObject();
            return offset;
        };

        static createWeapon(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, damage: number): flatbuffers.Offset {
            Weapon.startWeapon(builder);
            Weapon.addName(builder, nameOffset);
            Weapon.addDamage(builder, damage);
            return Weapon.endWeapon(builder);
        }

        /**
         * @returns WeaponT
         */
        unpack(): WeaponT {
            return new WeaponT(
                this.name(),
                this.damage()
            );
        };

        /**
         * @param WeaponT _o
         */
        unpackTo(_o: WeaponT): void {
            _o.name = this.name();
            _o.damage = this.damage();
        };
    }

    export class WeaponT {
        /**
         * @constructor
         * @param string|Uint8Array|null name
         * @param number damage
         */
        constructor(
            public name: string | Uint8Array | null = null,
            public damage: number = 0
        ) {
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        pack(builder: flatbuffers.Builder): flatbuffers.Offset {
            const name = (this.name !== null ? builder.createString(this.name!) : 0);

            return Weapon.createWeapon(builder,
                name,
                this.damage
            );
        };
    }
}
/**
 * @constructor
 */
export namespace MyGame {
    export class MyGame {
        bb: flatbuffers.ByteBuffer | null = null;

        bb_pos: number = 0;
      static Sample: any;

        /**
         * @param number i
         * @param flatbuffers.ByteBuffer bb
         * @returns MyGame
         */
        __init(i: number, bb: flatbuffers.ByteBuffer): MyGame {
            this.bb_pos = i;
            this.bb = bb;
            return this;
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param MyGame= obj
         * @returns MyGame
         */
        static getRootAsMyGame(bb: flatbuffers.ByteBuffer, obj?: MyGame): MyGame {
            return (obj || new MyGame()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @param MyGame= obj
         * @returns MyGame
         */
        static getSizePrefixedRootAsMyGame(bb: flatbuffers.ByteBuffer, obj?: MyGame): MyGame {
            bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
            return (obj || new MyGame()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
        };

        /**
         * @param flatbuffers.ByteBuffer bb
         * @returns boolean
         */
        static bufferHasIdentifier(bb: flatbuffers.ByteBuffer): boolean {
            return bb.__has_identifier('MGME');
        };

        /**
         * @returns MyGame.Character
         */
        CharactersType(): MyGame.Character {
            var offset = this.bb!.__offset(this.bb_pos, 4);
            return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : MyGame.Character.NONE;
        };

        /**
         * @param flatbuffers.Table obj
         * @returns ?flatbuffers.Table
         */
        Characters<T extends flatbuffers.Table>(obj: T): T | null {
            var offset = this.bb!.__offset(this.bb_pos, 6);
            return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
        };

        /**
         * @param flatbuffers.Builder builder
         */
        static startMyGame(builder: flatbuffers.Builder) {
            builder.startObject(2);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param MyGame.Character CharactersType
         */
        static addCharactersType(builder: flatbuffers.Builder, CharactersType: MyGame.Character) {
            builder.addFieldInt8(0, CharactersType, MyGame.Character.NONE);
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset CharactersOffset
         */
        static addCharacters(builder: flatbuffers.Builder, CharactersOffset: flatbuffers.Offset) {
            builder.addFieldOffset(1, CharactersOffset, 0);
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        static endMyGame(builder: flatbuffers.Builder): flatbuffers.Offset {
            var offset = builder.endObject();
            return offset;
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset offset
         */
        static finishMyGameBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {
            builder.finish(offset, 'MGME');
        };

        /**
         * @param flatbuffers.Builder builder
         * @param flatbuffers.Offset offset
         */
        static finishSizePrefixedMyGameBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {
            builder.finish(offset, 'MGME', true);
        };

        static createMyGame(builder: flatbuffers.Builder, CharactersType: MyGame.Character, CharactersOffset: flatbuffers.Offset): flatbuffers.Offset {
            MyGame.startMyGame(builder);
            MyGame.addCharactersType(builder, CharactersType);
            MyGame.addCharacters(builder, CharactersOffset);
            return MyGame.endMyGame(builder);
        }

        /**
         * @returns MyGameT
         */
        unpack(): MyGameT {
            return new MyGameT(
                this.CharactersType(),
                (() => {
                    let temp = MyGame.unionToCharacter(this.CharactersType(), this.Characters.bind(this));
                    if (temp === null) {
                        return null;
                    }
                    return temp.unpack()
                })()
            );
        };

        /**
         * @param MyGameT _o
         */
        unpackTo(_o: MyGameT): void {
            _o.CharactersType = this.CharactersType();
            _o.Characters = (() => {
                let temp = MyGame.unionToCharacter(this.CharactersType(), this.Characters.bind(this));
                if (temp === null) {
                    return null;
                }
                return temp.unpack()
            })();
        };
    }

    export class MyGameT {
        /**
         * @constructor
         * @param MyGame.Character CharactersType
         * @param MyGame.Sample.MonsterT|weapons.GunT|null Characters
         */
        constructor(
            public CharactersType: MyGame.Character = MyGame.Character.NONE,
            public Characters: MyGame.Sample.MonsterT | weapons.GunT | null = null
        ) {
        };

        /**
         * @param flatbuffers.Builder builder
         * @returns flatbuffers.Offset
         */
        pack(builder: flatbuffers.Builder): flatbuffers.Offset {
            const Characters = builder.createObjectOffset(this.Characters);

            return MyGame.createMyGame(builder,
                this.CharactersType,
                Characters
            );
        };
    }
}
